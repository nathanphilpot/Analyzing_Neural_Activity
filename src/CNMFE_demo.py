import bokeh.plotting as bplimport cv2import globimport holoviews as hvfrom IPython import get_ipythonimport loggingimport matplotlib.pyplot as pltimport numpy as npimport osimport psutilimport caiman as cmfrom caiman.source_extraction import cnmffrom caiman.source_extraction.cnmf.cnmf import load_CNMFfrom caiman.utils.utils import download_demofrom caiman.utils.visualization import inspect_correlation_pnr, nb_inspect_correlation_pnrfrom caiman.motion_correction import MotionCorrectfrom caiman.source_extraction.cnmf import params as paramsfrom caiman.utils.visualization import plot_contours, nb_view_patches, nb_plot_contourfrom caiman.utils.visualization import view_quilttry:    if __IPYTHON__:        get_ipython().run_line_magic('load_ext', 'autoreload')        get_ipython().run_line_magic('autoreload', '2')        # get_ipython().run_line_magic('matplotlib', 'qt')  #uncomment to run in qt modeexcept NameError:    passtry:    cv2.setNumThreads(0)except:    pass#import data. The recording filepath below should be updated so it points correctly. You can get it from Caiman's gitmovie_path = "/Users/nathan/Desktop/data_endoscope.tif"movie_orig = cm.load(movie_path)cm.play_movie(movie_orig)#set up processingprint(f"You have {psutil.cpu_count()} CPUs available in your current environment")num_processors_to_use = 8if 'cluster' in locals():  # 'locals' contains list of current local variables    print('Closing previous cluster')    cm.stop_server(dview=cluster)print("Setting up new cluster")_, cluster, n_processes = cm.cluster.setup_cluster(backend='multiprocessing',                                                  n_processes=num_processors_to_use,                                                  ignore_preexisting=False)print(f"Successfully set up cluster with {n_processes} processes")# dataset dependent parametersfrate = 10                       # movie frame ratedecay_time = 0.4                 # length of a typical transient in seconds# motion correction parametersmotion_correct = True    # flag for performing motion correctionpw_rigid = False         # flag for performing piecewise-rigid motion correction (otherwise just rigid)gSig_filt = (3, 3)       # sigma for high pass spatial filter applied before motion correction, used in 1p datamax_shifts = (5, 5)      # maximum allowed rigid shiftstrides = (48, 48)       # start a new patch for pw-rigid motion correction every x pixelsoverlaps = (24, 24)      # overlap between patches (size of patch = strides + overlaps)max_deviation_rigid = 3  # maximum deviation allowed for patch with respect to rigid shiftsborder_nan = 'copy'      # replicate values along the boundariesmc_dict = {    'fnames': movie_path,    'fr': frate,    'decay_time': decay_time,    'pw_rigid': pw_rigid,    'max_shifts': max_shifts,    'gSig_filt': gSig_filt,    'strides': strides,    'overlaps': overlaps,    'max_deviation_rigid': max_deviation_rigid,    'border_nan': border_nan}parameters = params.CNMFParams(params_dict=mc_dict)#motion correctionif motion_correct:    # do motion correction rigid    mot_correct = MotionCorrect(movie_path, dview=cluster, **parameters.get_group('motion'))    mot_correct.motion_correct(save_movie=True)    fname_mc = mot_correct.fname_tot_els if pw_rigid else mot_correct.fname_tot_rig    if pw_rigid:        bord_px = np.ceil(np.maximum(np.max(np.abs(mot_correct.x_shifts_els)),                                     np.max(np.abs(mot_correct.y_shifts_els)))).astype(int)    else:        bord_px = np.ceil(np.max(np.abs(mot_correct.shifts_rig))).astype(int)        # Plot shifts        plt.plot(mot_correct.shifts_rig)  # % plot rigid shifts        plt.legend(['x shifts', 'y shifts'])        plt.xlabel('frames')        plt.ylabel('pixels')        plt.gcf().set_size_inches(6,3)    bord_px = 0 if border_nan == 'copy' else bord_px    fname_new = cm.save_memmap(fname_mc, base_name='memmap_', order='C',                               border_to_0=bord_px)else:  # if no motion correction just memory map the file    fname_new = cm.save_memmap(movie_path, base_name='memmap_', order='C', border_to_0=0, dview=cluster)    movie_corrected = cm.load(mot_correct.mmap_file) # load motion corrected movieds_ratio = 0.2cm.concatenate([movie_orig.resize(1, 1, ds_ratio) - mot_correct.min_mov*mot_correct.nonneg_movie,                movie_corrected.resize(1, 1, ds_ratio)],                 axis=2).play(fr=10,                              gain=0.9,                              magnification=2) 